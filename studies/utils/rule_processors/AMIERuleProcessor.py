import os 
import sys 
import logging
from pathlib import Path
import colorama
from colorama import Fore, Style
import json
from dataclasses import asdict, dataclass
from typing import Dict, List, NamedTuple, Tuple, Union, Optional
import re
from collections import Counter
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../src/utils')))
#sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '../')))
#sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../../')))

from rules import Rule, RuleIO

# Initialize colorama
colorama.init(autoreset=True)

class ColoredFormatter(logging.Formatter):
    def format(self, record):
        if record.levelno == logging.INFO:
            record.msg = f"{Fore.GREEN}{record.msg}{Style.RESET_ALL}"
        elif record.levelno == logging.ERROR:
            record.msg = f"{Fore.RED}{record.msg}{Style.RESET_ALL}"
        elif record.levelno == logging.WARNING:
            record.msg = f"{Fore.YELLOW}{record.msg}{Style.RESET_ALL}"
        return super().format(record)

class RuleCompatibilityChecker:
    def __init__(self, compatibility_dict: Dict[str, List[str]]):
        self.compatibility_dict = compatibility_dict

    def is_rule_compatible(self, rule) -> bool:
        try:
            body = rule.body
            head = rule.head
        except Exception as e:
            logging.error(f"Error extracting rule attributes: {e}")
            return False

        body_keys = [f"{pred.relation.split('.')[0]}___sep___{pred.relation.split('.')[1]}" for pred in body if '.' in pred.relation]
        head_keys = [f"{pred.relation.split('.')[0]}___sep___{pred.relation.split('.')[1]}" for pred in head if '.' in pred.relation]

        for body_key, head_key in zip(body_keys, head_keys):
            if body_key not in self.compatibility_dict or head_key not in self.compatibility_dict[body_key]:
                return False
        return True

    def check_rule_compatibility(self, filepath: str) -> List[Dict[str, Union[Dict, bool]]]:
        try:
            with open(filepath, 'r') as file:
                data = json.load(file)
        except Exception as e:
            logging.error(f"Error reading JSON file {filepath}: {e}")
            return []

        for rule_dict in data:
            try:
                rule = RuleIO.rule_from_dict(rule_dict)
                compatible = self.is_rule_compatible(rule)
                rule_dict["compatible"] = compatible
            except Exception as e:
                logging.error(f"Error processing rule: {e}. Rule data: {rule_dict}")
                rule_dict["compatible"] = False

        return data

class AMIERuleProcessor:
    def __init__(self, results_dir: Path):
        self.results_dir = results_dir
        self.logger = logging.getLogger("AMIERuleProcessor")
        self.logger.handlers = []
        handler = logging.StreamHandler()
        handler.setFormatter(ColoredFormatter('%(asctime)s - %(levelname)s - %(message)s'))
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.INFO)
        self.successes = []
        self.failures = []

    def process_rules(self):
        """Process the rules generated by AMIE."""
        try:
            self.logger.info(f"Processing AMIE rules from {self.results_dir} ")
            for database in self.results_dir.iterdir():
                if database.is_dir():
                    self.logger.info(f"Processing database {database}")
                    self.database_path = database
                    print(f"Processing database {database}")
                    self.compute_compatibility(database)

        except Exception as e:
            self.failures.append(f"AMIERuleProcessor failed: {e}")
            self.logger.error(f"AMIERuleProcessor failed: {e}")

    def compute_compatibility(self, database):
        try:
            self.logger.info("Calculating compatibility scores...")
            self.logger.info(f"Reading AMIE results from {database}")
            database_name = database.stem
            amie3_results_filename = f"amie3_{database_name}_results.json"
            results_json = os.path.join(database, "amie3", amie3_results_filename)
            compatibility_file = os.path.join(database, "matilda", f"compatibility_{database_name}.json")

            with open(compatibility_file, "r") as cfile:
                compatibility_dict = json.load(cfile)

            rules = RuleIO.load_rules_from_json(results_json)
            checker = RuleCompatibilityChecker(compatibility_dict)
            
            compatibility_results = checker.check_rule_compatibility(results_json)
            # save the compatibility results as results in the database directory
            output_file = os.path.join(database, "matilda", f"compatibility_results_{database_name}.json")
            with open(output_file, 'w') as file:
                json.dump(compatibility_results, file, indent=4)

        except Exception as e:
            self.logger.error(f"Erreur lors du calcul de compatibilit√©: {e}")

    def main(self):
        """Main method to execute the processing."""
        self.process_rules()

if __name__ == "__main__":
    results_dir = Path("../main/data/results/")
    processor = AMIERuleProcessor(results_dir)
    processor.main()

